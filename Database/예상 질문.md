## Database 예상 질문

<details>
<summary>Click to toggle contents of `code`</summary>
```
CODE!
```
</details>

## 목차

1. [관계형데이터베이스(RDB) 관련](#관계형데이터베이스rdb-관련)
1. [트랜잭션 관련](#트랜잭션-관련)
1. [NoSQL 관련](#nosql-관련)
1. [인덱스 관련](#인덱스-관련)
1. [보안 관련](#보안-관련)

## 관계형데이터베이스(RDB) 관련

<details>
<summary>Q.기본키가 되기 위해 필요한 조건에 대해 말씀해주세요</summary>
```
CODE!
```
</details>

<details>
<summary>Q.기본키가 되기 위해 필요한 조건에 대해 말씀해주세요</summary>
```
CODE!
```
</details>


## 트랜잭션 관련

<details>
<summary>Q.트랜잭션이 뭔지 설명해주세요</summary>

transaction는 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행합니다. transaction은 하나 이상의 query를 포함해야 하고, ACID라고 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야합니다. 
</details>

<details>
<summary>Q.트랜잭션의 특징에는 어떤게 있나요?</summary>

트랜잭션은 ACID라는 4가지 특징이 있습니다.
1. 원자성은 transaction에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야 한다는 뜻입니다.
2. 일관성은 트랜잭션 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미합니다. 일관성 있다는 것은 트랜잭션의 결과로 데이터 제약조건에 위배되는 상태가 되지 않는 것을 말합니다.  
3. 고립성은 각 transaction 작업중에 다른 transaction이 끼어들지 못하도록 보장하는 것을 의미합니다. 그래서 동시에 수행되는 transaction이 동일한 data를 가지고 충돌하지 않도록 제어해줘야 합니다. 이를 동시성제어(concurrency control) 라고합니다.
4. 지속성은 성공적으로 수행된 transaction은 데이터베이스에 영원히 반영되어야 함을 의미합니다. transaction이 완료되어 저장이 된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야 합니다.
</details>

<details>
<summary>Q.트랜잭션 격리 수준(isolation level)에 대해서 알고 있나요? 알고 있다면 설명해주세요</summary>

트랜 잭션 격리수준은 멀티-트랜잭션 환경에서 발생할 수 있는 이상현상에 대해 고립 수준을 정해서 동시성을 제어하는 방법이며 4가지가 있습니다.
1. read-uncommitted: 다른 트랜잭션이 커밋하지 않은 데이터에 대해서도 조회할 수 있는 고립수준으로. dirty-read 문제가 발생합니다.
2. read-committed: 다른 트랜잭션이 커밋한 데이터에 대해서만 조회할 수 있는 고립수준으로 dirty-read 문제는 발생하지 않지만 unrepeatable-read 문제가 발생합니다.
3. repeatable-read: 현재 트랜잭션이 시작하기 이전에 커밋된 데이터에 대해서만 조회할 수 있는 고립수준으로 unrepeatable-read 문제는 발생하지 않지만 phantom-read 문제가 발생합니다.
4. serializable: 가장 높은 고립수준으로 3가지 이상현상이 모두 발생하지 않지만 동시성이 가장 떨어지는 고립수준입니다.
</details>

## NoSQL 관련

## 인덱스 관련

<details>
<summary>Q.인덱스가 왜 필요할까요?</summary>

인덱스가 필요한 이유는 조회 성능 향상을 위해서입니다. 인덱스를 사용하면 테이블에서 데이터 조회 시 full-scan이 아니라 range-scan을 할 수 있기 때문에 조회 성능 향상을 위해 사용합니다.
</details>

<details>
<summary>Q.인덱스 컬럼을 정해야 한다면 어떤 기준을 가지고 정할 건가요?</summary>

크게 3가지 기준을 가지고 정할 것입니다.
1. 자주 조회하는 컬럼. 인덱스는 조회 성능 향상을 위한 장치이므로 자주 조회하는 컬럼에 적용해야 바람직합니다.
2. 카디널리티가 큰 컬럼. 성별(남/여)보다 주민등록번호 같은 컬럼으로 인덱스를 적용해야 인덱스를 통해 더 많은 데이터를 걸러낼 수 있습니다. 
3. 자주 업데이트 되지 않은 컬럼. 잦은 수정/삭제는 인덱스 테이블 크기가 데이터 테이블 크기보다 커질 수 있으므로 수정이 최소화되는 컬럼을 고려해야 합니다. 
</details>

<details>
<summary>Q.인덱스가 좋으면 모든 컬럼 마다 인덱스를 걸어놓으면 되지 않을까요?</summary>

1. 모든 컬럼에 인덱스를 적용하면 테이블로부터 파생되는 인덱스 테이블이 많아져 삽입/수정/삭제 시 많은 연산량과 디스크 공간 차지로 성능이 안 좋아질 수 있습니다.
2. 그러므로 자주 조회하는 컬럼에 대한 조회 성능 향상 목적에 부합할 대만 인덱스를 고려하는 것이 바람직합니다.
</details>

<details>
<summary>Q.인덱스 내부 동작 방식에 대해 말씀해주세요</summary>

인덱스를 선언하면, 테이블로부터 파생되는 인덱스 테이블이 만들어집니다.
1. 그리고 인덱스 컬럼 기준으로 테이블이 key-value 형태로 저장됩니다.
2.
</details>

<details>
<summary>Q.인덱스 구현을 위한 자료구조로 hash-table과 b+tree가 있는데 왜 주로 b+tree를 사용할까요?</summary>

데이터베이스에서는 범위 조건으로 조회하는 경우도 많기 때문에 b+tree를 사용합니다.
1. 해시테이블의 경우 해시함수를 적용하게 되면 데이터간의 정렬 정보가 사라지게 됩니다. 그러므로 범위 조건 검색 시 시간이 더 오래걸립니다.
2. 반면에 b+tree의 경우 내부적으로 자료들이 정렬되어 있으므로 범위 조건 쿼리 시 더 빠르게 검색을 할 수 있습니다.
</details>

## 보안 관련


