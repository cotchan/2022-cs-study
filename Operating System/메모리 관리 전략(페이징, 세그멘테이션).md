## 메모리 관리 전략

- 메모리 용량이 증가함에 따라 프로그램의 크기 또한 계속 증가하고 있기 떄문에 메모리는 언제나 부족합니다.
- 실행중인 모든 프로세스를 메모리 위에 올릴 수 없기 때문에 제한된 물리 메모리의 효율적인 사용이 필요.

## 목차

1. [스와핑(Swapping)](#스와핑swapping)
1. [페이징(Paging)](#페이징paging)
    - [등장배경](#등장배경)
    - [페이징(Paging)이란](#페이징paging이란)
    - [MMU(Memory Management Unit)](#mmumemory-management-unit) 
    - [동작방식](#동작방식)
    - [페이지 테이블](#페이지-테이블)
    - [보호(해킹 방지)와 공유(Sharing)메모리 낭비 방지](#보호해킹-방지와-공유sharing메모리-낭비-방지)
    - [페이징 장점](#페이징-장점)
    - [페이징 단점](#페이징-단점)
    - [TLB(Translation Lookaside Buffer)](#tlbtranslation-lookaside-buffer)
    - [Page Fault](#page-fault)
1. [세그멘테이션(Segmentation)](#세그멘테이션segmentation) 
    - [동작방식](#동작방식-1)
    - [세그멘테이션 장점](#세그멘테이션-장점)
    - [세그멘테이션 단점](#세그멘테이션-단점)
1. [페이징과 세그멘테이션 혼용](#페이징과-세그멘테이션-혼용)
1. [예상 질문]()

---

## 스와핑(Swapping)

- `주기억장치에 적재`한 하나의 프로세스와 `보조기억장치에 적재`한 다른 프로세스의 메모리를 교체하는 기법.
  - `스와핑(Swapping)의 단위`는 `프로세스`
- 메모리는 크기가 작기 때문에, 현재 모든 프로세스가 user space 메모리를 다 차지하고 있는데 `새로운 프로세스를 실행`하면, `기존의 프로세스` 중에 현재 실행중이지 않은 프로세스를 임시로 디스크에 보냈다가 다시 메모리에 로드해야 하는 상황이 생긴다. 
  - 이 때 디스크로 내보내는 것을 `swap-out`, 메모리로 들여보내는 것을 `swap-in`이라고 한다. 
  - `CPU에서 실행중이지 않는 프로세스`를 저장장치의 Swap 영역으로 이동하여 메모리를 확보한다.
- Context Switching으로 인한 오버헤드가 발생할 수 있고 속도가 느리지만, 메모리 공간 확보에는 효율적인 방법이다.
  - 스와핑(Swapping)하는데 걸리는 시간의 대부분은 디스크 전송 시간.

![스크린샷 2022-09-12 오후 6 28 53](https://user-images.githubusercontent.com/75410527/189620211-82def1d6-fc5e-47a9-9756-e1c4a287c6d0.png)

### Swap-out

- `CPU에서 실행중이지 않는 프로세스`를 저장장치의 Swap 영역으로 이동하여 메모리를 확보
- 쫓아낼 때 메모리에 있던 프로세스의 정보를 아예 없애버리면 안되므로 보조기억장치(하드디스크, SSD)에 저장을 수행

### Swap-in

- 보조기억장치로 쫓아냈던 프로세스를 다시 메모리에 올려서 해당 프로세스를 실행시켜주는 것 

### 동작 방식

- `중기 스케줄러`에 의해 swap-out 시킬 프로세스를 선정하여 우선순위가 낮은 프로세스를 swap-out 시키고, 우선 순위가 높은 프로세스를 메모리에 swap-in 하는 방식

---

## 페이징(Paging)

### 등장배경

- `다중 프로그래밍 환경`으로 바뀌면서 다양한 프로그램들이 메인 메모리 공간에 올라가서 프로세스로 되어 동작하기 시작했다. 
  - 프로그램들은 실행될 때 `메인 메모리`로 적재되고 사용이 다 되면 다시 `하드디스크`로 돌아가게 된다. 
- 이런 작동이 반복되면서 메모리 공간에는 `hole`이라고 하는 빈 공간이 만들어지게 된다. 
- 이런 빈 공간이 흩어져 있게 되어 총 합으로는 충분한 공간의 빈 메모리 공간이 있을지라도 사용할 수 없는 공간이 되어버린다. 
  - 왜냐하면 `프로세스는 연속된 공간에서 존재해야 동작`했기 때문이다. 
  - 이러한 문제를 `외부 단편화`라고 한다. 
- 그리고 외부 단편화를 해결하고자 `연속 메모리 할당`을 하는 방식에 차이를 두기도 하고, `Compaction`기법을 사용하기도 했지만 여전히 메모리 공간이 낭비가 되고 그렇지 않으면 고비용이 들게 되었다. 그래서 나온 해결 방법이 바로 페이징이다.

### 페이징(Paging)이란

- 메모리와 프로세스를 `동일한 크기(물리적으로 일정한 크기)`로 잘라 페이지 단위로 실행시킴으로써 외부 단편화 문제 해결하는 기법
- **프로세스의 할당받는 물리 주소 공간이 `연속되지 않아도 되는` 메모리 관리 기법**
  - 페이징은 프로세스가 연속된 메모리 공간에 할당되어야 한다는 이론을 부셔버린 개념 
- `메모리`는 `프레임(Frame)`, `프로세스`는 `페이지(Page)`라는 고정 크기의 블록으로 분할된다.
  - 블록의 크기는 2의 거듭제곱 꼴 
- 한 프로세스가 사용하는 공간은 여러 page로 나뉘어 관리되고, 각각의 page는 `순서와 관계없이` frame에 매핑되어 저장

### MMU(Memory Management Unit)

- CPU와 메인 메모리 사이에서 존재하는데 재배치 레지스터를 가지고 있다. 역할은 `논리 주소와 물리 주소의 변환`을 주관한다. 
  - 논리 주소
    - `CPU가 요구하는 주소 값`으로 CPU가 생성하는 주소. 가상 주소(virtual address)라고도 함.
  - 물리 주소
    - `메인 메모리가 인식하여 찾는 주소 값`이다.
- MMU의 역할은, 메인 메모리가 임의의 공간에 프로그램을 적재하면 이 메모리 주소 값에 맞게 재배치 레지스터 값을 설정하여 CPU가 이 프로세스에 대한 논리 주소를 요구할 때 물리 주소로 바꾸어 맞는 메모리 공간 주소를 지칭하게 해준다. 

  <img width="619" alt="paging_01" src="https://user-images.githubusercontent.com/75410527/189633654-ec30a0cb-e664-402b-a398-d32dcac847a1.png">

### 동작방식

- 프로세스가 순서대로 메모리에 저장되어 있지 않기 때문에 프로세스를 실행하기 위해선 `어느 page가 어느 frame에 들어있는지` 알아야 한다.
  - 프로세스의 물리 주소 공간이 연속되지 않아도 프로세스가 실행되는 이유는 `페이지 테이블 갯수만큼 MMU`를 만들어놓았기 때문. MMU는 페이지 테이블을 가지게 된다.
  - 그리고 페이지 테이블은 `프로세스마다 존재`한다.
- 이에 대한 정보가 `page table`에 저장되어 있고, 이를 사용하여 `논리적 주소`를 `물리적 주소`로 변환한다. 

  <img width="505" alt="page_03" src="https://user-images.githubusercontent.com/75410527/189635177-ee50a549-3379-4550-8289-a0d4960cc199.png">


- `MMU`의 재배치 레지스터 방식을 활용해 CPU가 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록 함
 
  <img width="342" alt="paging_02" src="https://user-images.githubusercontent.com/75410527/189633701-e5ede34a-a916-4fb0-9fd9-bb21b815ed8f.png">

  - CPU에서 나오는 주소는 `페이지 번호(p)`와 `페이지 오프셋(d)` 두 개의 부분으로 나눠짐  

  <img width="619" alt="paging_01" src="https://user-images.githubusercontent.com/75410527/189633654-ec30a0cb-e664-402b-a398-d32dcac847a1.png">

  - MMU가 CPU에 의해 생성된 논리 주소를 물리 주소로 변환하는 과정
    1. 페이지 번호 p를 추출하여 페이지 테이블의 인덱스로 사용한다.
    2. 페이지 테이블에서 해당 프레임 번호 f를 추출한다.
    3. 논리 주소의 페이지 번호 p를 프레임 번호 f로 바꾼다.
  - 오프셋 d는 변하지 않기 때문에 대체되지 않으며, 프레임 번호와 오프셋은 이제 물리 주소를 구성한다.

### 페이지 테이블

#### PTE(Page Table Entry)

- 페이지 테이블 엔트리는 `페이지 테이블의 레코드`이다.
- PTE의 각 필드에는 일반적으로 다음 내용이 기록된다.
  - 페이지 프레임주소(Page Frame Number)
  - 플래그 비트
    - 접근 비트(Accessed bit, Reference bit) : 페이지에 대한 접근(참조)가 있었는지를 나타낸다.
    - 변경 비트(Dirty bit) : 페이지 내용의 변경이 있었는지를 나타낸다.
    - 존재 비트(Valid bit, Present bit) : 현재 페이지에 할당된 프레임이 있는지(유효한지)를 나타낸다.
    - 읽기/쓰기 비트(Read/Write bit) : 읽기/쓰기에 대한 권한을 표시한다.

![pte](https://user-images.githubusercontent.com/75410527/190046206-80f7e491-e07a-4464-8892-9e72ea9d81ab.png)

#### Linear page table

- 그냥 모든 Virtual Address의 page를 순서대로 다 담아놓은 page table
- 하지만 페이지 테이블이 크기가 커지는 문제가 있어서 현대에는 쓰이지 않음
  - 예시: `2^64` 주소 공간을 8KB(`2^13`) 기준으로 페이징을 하게 되면, 페이징 테이블 크기만 해도 `2^51`

![pg_table_01](https://user-images.githubusercontent.com/75410527/190047235-0d9d7333-99d5-4289-96c9-7c800a61742d.png)

#### Hierarchy page table

- `페이징 테이블`을 `다시 페이징`하는 방식
  - '안쓰는 page table은 할당하지 않고 있다가 필요할 때만 할당하면 되지 않을까?'라는 아이디어
- 허나 여전히, `2^64` 같이 큰 주소공간에는 계층을 적용해도 `페이지 테이블 크기가 커진다`는 문제 존재

<img width="528" alt="hpage_01" src="https://user-images.githubusercontent.com/75410527/190052729-32b2732d-d154-4aad-8955-3c37c6a511ef.png">

- 기존에 `2^32` 주소 공간을 `2^12`로 페이징했을 때 Linear가 `2^20` 페이지 테이블 크기를 가졌다면
- 계층 페이징 테이블에서는 2^20 `페이지 테이블도 페이지로 나누면` 페이지 번호는 10비트 짜리 페이지 번호와 10비트 짜리 페이지 오프셋으로 나누어진다.
- p1은 `바깥 페이지 테이블의 인덱스`이고, p2는 `안쪽 페이지 테이블`의 페이지 내의 오프셋

<img width="344" alt="hpage_02" src="https://user-images.githubusercontent.com/75410527/190052755-6b21b714-830b-44dd-9e70-bdecb8da72ff.png">

- 2단계 32비트 페이징 구조에서의 주소 변환 예시

<img width="559" alt="hpage_03" src="https://user-images.githubusercontent.com/75410527/190052767-591fd4e1-df5e-4fdf-8862-2b64430c64b0.png">


#### Hashed page table

- 주소 공간이 `32비트`보다 커지면 가상 주소를 해싱하는 해시 페이지 테이블 방식을 많이 사용
- 해시 페이지 테이블의 각 PTE는 연결 리스트를 가지고 있음
  1. 가상 페이지 번호
  2. 매핑되는 페이지 프레임 번호
  3. 연결 리스트상의 다음 원소 포인터
- 동작방식
  1. 가상 주소 공간으로부터 페이지 번호가 오면 그것을 해싱한다.
  2. 그것으로 해시 페이지 테이블에서 연결 리스트를 따라가며 첫 번째 원소와 가상 페이지 번호를 비교해 본다.
  3. 만약 일치하면 그에 대응하는 페이지 프레임 번호를 가져와 물리 주소를 얻는다.
  4. 일치하지 않는다면 다음 원소로 넘어가 가상 페이지 번호 비교를 반복한다. 

<img width="601" alt="hash_page_table" src="https://user-images.githubusercontent.com/75410527/190051980-ed08efb0-d04a-4554-ba48-d04c720f1abf.png">

### 보호(해킹 방지)와 공유(Sharing)메모리 낭비 방지

#### 보호

- 비트를 둬서 해당 페이지에 대한 접근 제한을 두는 방식으로 각 페이지 테이블마다 `read write execute용 1비트씩을 추가`한다. 
  - 비트가 111이라면 페이지 테이블에서 읽은 `프레임 넘버에 있는 데이터에 대해`서 읽기/쓰기/실행할 수 있는 것을 의미한다.
- 권한이 없는데(비트가 0) 읽거나 쓰거나 실행 하려고 CPU가 바꾸려 한다면 페이지 테이블에서 CPU로 인터럽트가 걸리게 된다. 
  - CPU는 지금 하던 일을 중지하고 OS에 특정 루틴으로 가서 이런 잘못된 일을 하는 프로세스를 강제 종료하게 된다.
- 페이징을 사용한다면, 어차피 CPU가 요구하는 모든 주소는 페이지 테이블을 거치게 된다. 그래서 여기에 rwx 비트를 둬서 해당 페이지에 대한 접근 제한을 두는 것

<img width="805" alt="page_001" src="https://user-images.githubusercontent.com/75410527/189834213-d5482dd1-cf27-4198-a8d2-2db15fa20e04.png">

#### 공유(Sharing)메모리 낭비 방지

- 동일한 프로그램이 여러 프로세스로 실행중이라면, 이들의 `code 영역은 동일`할 것이다. 
- 그래서 페이징을 사용하는 경우 코드 영역에 해당되는 페이지 테이블이 같은 값을 가리키도록 한다.
- 그래서 Context Switching이 발생해도 페이지 테이블에서 코드 영역을 가리키는 부분은 바뀌지 않게 된다. 

### 페이징 장점

- page들이 연속할 필요가 없어 외부 단편화를 해결 가능
- 할당과 해제가 빠르다(프로세스 단위가 아닌 page 단위로 관리하므로).
- swap out이 간단하다(프로세스 단위가 아닌 page 단위로 관리하므로).

### 페이징 단점

- 내부 단편화 문제 발생
  - 하지만 프로세스의 크기가 페이지 크기의 배수가 아니라면 마지막 프로세스의 페이지는 한 프레임을 다 채울 수 없다.
  - 따라서 이런 공간이 메모리 안에서 빈 공간으로 남아 낭비되게 된다. 
- page table을 저장하기 위한 메모리가 추가로 소모된다.
  - page table은 `프로세스마다 존재`하며 `메인 메모리에 상주`한다.
- 페이징 기법을 사용하면 메모리에 2번 접근해야 함. page table 접근(1번), 실제 주소를 구하고 메모리에 접근(2번)
  - 이를 보완하기 위해 `TLB(Translation Look-aside Buffer)`라는 하드웨어(CPU 내에 들어가는 하드웨어 장치)의 도움을 받아 해결 
    - `TLB`는 참조했던 페이지를 담아주는 `캐시 역할` 
    - TLB는 key-value pair로 데이터를 관리하는 acssociative memory이며, CPU는 page table보다 TLB을 우선적으로 참조한다.

### TLB(Translation Lookaside Buffer)

- 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용하는 캐시
- TLB의 위치는 `CPU와 CPU 캐시 사이에 존재`하며 `Hardware Cache`이다.
  - 현재 모든 데스크탑 및 서버용 프로세서는 하나 또는 그 이상의 TLB를 메모리 관리 하드웨어에 가지고 있다.

![tlb_img](https://user-images.githubusercontent.com/75410527/190044334-f8bfa229-dfdc-4f69-a340-8cb03e413410.png)

#### 동작방식

1. 가상주소가 주어지면 TLB를 살펴본다.
1. 가상주소가 TLB에 존재하면(TLB Hit) => 바로 프레임 번호 추출 => 물리주소 구성
1. TLB에 해당 페이지테이블 항목이 없다면(TLB Miss) => 페이지 테이블을 찾아가서 페이지 번호로 조회
1. valid bit가 1인 경우, 해당 페이지는 메모리(주기억장치)에 존재 => 페이지테이블에 있는 프레임 번호 이용 => 물리주소 구성 및 TLB 갱신
1. valid bit가 0인 경우, 해당 페이지는 메모리에 없으므로 Page Fault => 페이지 교체 

<img width="897" alt="스크린샷 2022-09-14 오전 11 07 26" src="https://user-images.githubusercontent.com/75410527/190043325-83e19e89-a1d5-411b-acba-dc2b066138c5.png">


- 페이징과 TLB 동작

<img width="672" alt="스크린샷 2022-09-14 오전 11 08 12" src="https://user-images.githubusercontent.com/75410527/190043345-7420484a-d7a2-490b-952a-4e987d11cf19.png">


### Page Fault

- 물리 메모리에 CPU가 요청한 페이지가 없는 경우를 Page Fault라 한다.
- 이 경우 스왑 영역(보조기억장치에 위치한 가상 메모리 영역)에서 페이지를 찾아 물리 메모리에 로드

#### Page Fault 처리 과정

1. OS는 두 가지 경우 중 한 가지로 판단
    1. `invalid 참조`라면 abort 처리
        - 메모리 할당이 contiguous한 경우 limit만 비교해도 메모리를 보호 가능  
        - page table의 각 항목에는 `valid-invalid bit`가 붙어있다. 
            - 그 값이 `valid`라면 `해당 페이지에 접근이 가능`하다는 것을 의미
            - 그 값이 `invalid`라면 해당 페이지가 logical address space에 속하지 않아 접근할 수 없다는 것을 의미
    2. 그냥 메모리에 없는 경우
1. free frame을 찾음
1. 페이지를 disk로부터 frame에 swap해줌.
1. page table을 유효한 값으로 validation bit을 v로 변경해줌.
1. page fault를 발생시켰던 명령어를 다시 실행.

---

## 세그멘테이션(Segmentation)

- 세그멘테이션은 프로세스를 `논리적 내용을 기반`으로 나눠서 메모리에 배치하는 것을 의미

![seg_01](https://user-images.githubusercontent.com/75410527/189818092-33a81ba6-747e-4be8-aada-e0ec9581e920.png)

- 세그멘테이션은 프로세스를 `세그멘트의 집합`으로 표현함. 세그먼트는 논리 단위로 아래와 같은 것들이 해당  
  - main program
  - procedure
  - function
  - method
  - object
  - stack
  - local variable
  - global variable
  - 프로세스를 code영역, data영역, stack영역 등으로 나누는 것 또한 세그멘테이션이라고 할 수 있다. 
- 세그멘테이션은 물리적인 크기가 아닌, 논리적 내용(의미가 같은 단위)의 단위로 자르기 때문에 `세그먼트들의 크기는 같지 않다.`

### 동작방식

- `프로세스를 어떻게 자르는가`에 대한 방법을 빼고 메모리에 할당하는 방법에 대해서는 페이징과 방법이 같다 
  - 세그멘테이션도 페이징과 비슷하게 `세그멘트 테이블`을 가지고 있다.
  - 페이징과 비슷하게 논리주소가 `segment-number, offset`으로 이루어져있다.
- MMU 내의 재배치 레지스터를 이용하여 논리 주소를 물리 주소로 바꾸어 주는 방식을 취한다.
  - MMU는 세그멘트 테이블로, CPU에서 할당한 논리 주소에 해당하는 물리 주소의 위치를 가지고 있다.

  ![seg_02](https://user-images.githubusercontent.com/75410527/189819769-09dc024c-84ab-41c6-8427-942ad0a1ecd7.png)

  - 세그멘트 테이블이 페이지 테이블과 다른 점은, `세그먼트의 크기가 일정하지 않기 때문에` `limit`이라는 정보가 추가로 들어 있다.
    - 논리 주소에 대한 요청이 들어오면, 세그먼트 번호를 토대로 해당 테이블 필드로 가서, 시작 위치(base) 및 한계 값(limit)을 파악한다.
  - limit 필드는 각 `세그먼트의 크기(한계값)`을 의미한다. 그래서 offset 값이 limit을 넘어서면 `segment violation` 예외 처리
  - 예시, 다음과 같은 상황을 가정
    1. 요청 논리주소 <2, 100> -> base[2] + 100 = 4400(물리주소)
    2. 요청 논리주소 <1, 500> -> base[1] + 500인데, base[1]의 limit이 400이므로 범위를 벗어나 인터럽트가 발생
   
  ![seg_03](https://user-images.githubusercontent.com/75410527/189819787-2555501e-5c97-4e95-a6e0-fc29230b69c5.png)
  

### 세그멘테이션 장점

- 세그멘테이션은 페이징보다 `보호와 공유의 기능`면에서 장점을 가진다. 
  - 왜냐하면 프로세스를 이미 내용적인 측면(Segment)으로 다 나눴기 때문이다.
  - 코드 영역은 코드 영역으로 잘리고, 중요한 세그먼트, 중요하지 않은 세그먼트를 논리적인 내용 측면으로 잘라놓음.
- 보호
  - 세그멘테이션은 `read/write/execute` 권한을 테이블에 추가하는데, 이 때 이것을 논리적으로 나누기 때문에 해당 비트를 설정하기 간단하고 안전. 
    - `rwx` 비트를 만들어 해당 `세그먼트에 대한 접근 제어`를 가능하게 해줌
  - 반면, 페이징은 `code+data+stack` 영역이 존재할 때 이를 일정한 크기로 나누기 때문에 `영역이 섞여` 비트를 설정하기 까다로워질 수 있다. 
- 공유
  - 페이징은 영역이 섞일 가능성이 존재하지만, 세그멘테이션은 정확히 영역을 나누므로 더 효율적으로 공유를 할 수 있다.
  - 같은 프로그램을 사용하는 여러 개의 프로세스가 있다면, 메모리에 하나만 적재해서 프로세스의 세그먼트 테이블의 코드 영역이 같은 곳을 가리키게 만듦

### 세그멘테이션 단점

- `세그먼트는 크기`가 고정되어 있지 않고 `가변적`이다. 그러므로 `외부 단편화 문제`가 생길 수 있다.

---

## 페이징과 세그멘테이션 혼용

- 세그먼테이션은 `보호와 공유`면에서 효과적이고 페이징은 `외부 단편화 문제 해결`에 효과적이므로 두 가지 장점을 모두를 취하는 방법
- 세그먼트를 페이징한다.

![seg_04](https://user-images.githubusercontent.com/75410527/189824844-ffeb655f-15c8-4732-aaa0-847485ed432d.jpg)

- 프로세스를 처음에 세그먼트 단위로 자른다. 
  - 의미 있는 단위로 나누게 되면 보호와 공유를 하는 측면에 이점을 가질 수 있게 된다. 
  - 하지만 앞서 말했듯 외부 단편화가 발생할 수 있다. 
- 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 취한다. 
  - 그래서 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화가 발생하지 않는다. 
- 하지만 이와 같은 경우에는 테이블을 `두 가지를 모두 거쳐야 하므로` `속도 면에서 조금 떨어질 수 있다.`

## 예상 질문

### Paging과 Segmentation 장단점

|      | Paging                                                                                                       | Segmentation                                                                                              |
|------|--------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|
| 장점 | page들이 연속할 필요가 없어 외부 단편화 문제 해결                                                            | 세그멘테이션은 보호와 공유의 기능면에서 장점을 가진다.(왜냐하면 프로세스를 Segment로 다 나눴기 때문이다)  |
|      | 메모리와 프로세스를 물리적으로 같은 크기로 자르므로 외부 단편화 문제 해결                                    |                                                                                                           |
|      | 할당과 해제가 빠르다(프로세스 단위가 아닌 page 단위로 관리하므로)                                            |                                                                                                           |
| 단점 | 내부 단편화 문제 발생                                                                                        | 세그먼트 크기는 가변적이므로 외부 단편화 문제발생 가능                                                    |
|      | page table을 저장하기 위한 메모리가 추가로 소모된다.                                                         |                                                                                                           |
|      | 페이징 기법을 사용하면 메모리에 2번 접근해야 함. page table 접근(1번), 실제 주소를 구하고 메모리에 접근(2번) |                                                                                                           |


### TLB와 PT의 개념, 차이, 장단점

##### TLB(Translation Lookaside Buffer)

- 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용하는 캐시
- TLB의 위치는 `CPU와 CPU 캐시 사이에 존재`하며 `Hardware Cache`이다.
  - 현재 모든 데스크탑 및 서버용 프로세서는 하나 또는 그 이상의 TLB를 메모리 관리 하드웨어에 가지고 있다.

##### Page Table

- 프로세스가 순서대로 메모리에 저장되어 있지 않기 때문에 프로세스를 실행하기 위해선 `어느 page가 어느 frame에 들어있는지` 알아야 한다.
- 위 정보를 담고 있는 테이블

### TLB, PT 존재할 때 메모리 참조 순서

1. 가상주소가 주어지면 TLB를 살펴본다.
1. 가상주소가 TLB에 존재하면(TLB Hit) => 바로 프레임 번호 추출 => 물리주소 구성
1. TLB에 해당 페이지테이블 항목이 없다면(TLB Miss) => 페이지 테이블을 찾아가서 페이지 번호로 조회
1. valid bit가 1인 경우, 해당 페이지는 메모리(주기억장치)에 존재 => 페이지테이블에 있는 프레임 번호 이용 => 물리주소 구성 및 TLB 갱신
1. valid bit가 0인 경우, 해당 페이지는 메모리에 없으므로 Page Fault => 페이지 교체 

---

- 참고
  - [[운영체제]메모리 관리 전략(Memory Management Strategy)](https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy)
  - [[운영체제(OS)] 8. 메모리 관리(Memory Management)](https://rebro.kr/178)
  - [[운영체제]Swapping 스와핑(Swap 스왑)이란? 프로세스 교체, VMM과 차이](https://jhnyang.tistory.com/103)
  - [[OS] 메인 메모리(2) - 페이징 기법](https://dkswnkk.tistory.com/443?category=513905)
  - [[운영체제/OS] Page Fault와 Demand Paging](https://hidemasa.tistory.com/56)
  - [페이지 폴트 (Page Fault)](https://hooni-playground.com/939/)
  - [운영체제 17장 - 메모리 관리(4) : 페이징(1) -](https://copycode.tistory.com/98?category=740133)
  - [운영체제 18장 - 메모리 관리(5) : 페이징(2) -](https://copycode.tistory.com/102?category=740133)
  - [운영체제 19장 - 메모리 관리(6) : 페이징(3) -](https://copycode.tistory.com/107?category=740133)
  - [[운영체제] 세그멘테이션(Segmentation)이란?, 세그멘테이션 vs 페이징](https://code-lab1.tistory.com/57)
  - [운영체제 20장 - 메모리 관리(7) : 세그멘테이션(Segmentation) -](https://copycode.tistory.com/108)
  - [17. 내부 단편화와 페이지 테이블](https://100100e.tistory.com/262)
  - [[운영체제] TLB(Translation Lookaside Buffer), 캐시사상기법(직접사상, 연관사상), 페이지크기](https://blog.naver.com/PostView.naver?blogId=kgr2626&logNo=222147205118&redirect=Dlog&widgetTypeCall=true&directAccess=false)
  - [운영체제) TLB](https://m.blog.naver.com/babobigi/221469078499)
- 이미지 출처
  - [[운영체제]Swapping 스와핑(Swap 스왑)이란? 프로세스 교체, VMM과 차이](https://jhnyang.tistory.com/103) 
  - [[운영체제] 세그멘테이션(Segmentation)이란?, 세그멘테이션 vs 페이징](https://code-lab1.tistory.com/57) 
  - [운영체제 20장 - 메모리 관리(7) : 세그멘테이션(Segmentation) -](https://copycode.tistory.com/108)
  - [[OS] Paging - Smaller Table](https://rond-o.tistory.com/267)
  - [[운영체제] TLB(Translation Lookaside Buffer), 캐시사상기법(직접사상, 연관사상), 페이지크기](https://blog.naver.com/PostView.naver?blogId=kgr2626&logNo=222147205118&redirect=Dlog&widgetTypeCall=true&directAccess=false)
  - [(Translation-Lookaside Buffer)TLB](https://puzzle-puzzle.tistory.com/entry/Translation-Lookaside-BufferTLB)
