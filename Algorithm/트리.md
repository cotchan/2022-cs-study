## Index

[트리의 개념](#트리의-개념)

- [트리란](#트리란)
- [트리의 특징](#트리의-특징)
- [트리의 활용](#트리의-활용)

[트리의 종류](#트리의-종류)

- [이진 탐색 트리](#이진-탐색-트리)
- [자가 균형 이진 탐색 트리](#자가-균형-이진-탐색-트리)
- [힙](#힙)
- [트라이 자료구조](#트라이-자료구조)

[References](#References)



## 트리의 개념

### 트리란

트리는 `계층적 데이터를 표현`하는 데 이용하는 `비선형 자료구조`이다. (방향성이 있는 비순환 그래프이다.)

> 왜 해당 자료구조의 이름은 트리일까?
> 해당 자료구조의 모양이 나무를 뒤집어 놓은 것과 비슷해서 트리로 부른다.

> 선형 자료구조란?
> 자료들 간의 앞뒤 관계가 1:1인 자료구조로 배열, 링크드리스트, 스택, 큐 등이 있다.
> 비선형 자료구조란?
> 자료들 간의 앞뒤 관계가 1:n이거나 n:n인 자료구조로 트리와 그래프가 대표적이다.

<img width="942" alt="Screen Shot 2022-10-18 at 12 23 31 AM" src="https://user-images.githubusercontent.com/59877415/196218004-3b6c7580-6b29-4967-bcb9-a93558cd4654.png">

**노드** : 트리를 구성하는 기본 요소로 값과 하위 노드에 대한 포인터를 가지고 있다.

**간선** : 노드와 노드 간의 연결 선이다.

> 그림에서 A, B, C, D, E, F, G, H, I, J 모두 노드이다.
> 그리고 이들을 연결하는 선들은 모두 간선이다.

**루트 노드** : 트리 구조에서 부모가 없는 최상위 노드이다.

> 그림에서 A가 루트 노드이다.

**부모 노드** : 자식 노드를 가진 노드로 상대적인 개념이다.

**자식 노드** : 부모 노드의 하위 개념으로 상대적인 개념이다.

**형제 노드** : 같은 부모를 가지는 노드이다.

> 그림에서 C는 A의 자식 노드이고 H의 부모 노드이다.

**리프 노드** : 자식 노드가 없는 노드이다.

**내부 노드** : 자식 노드를 하나 이상 가진 노드이다.

>그림에서 E, F, G, H, I, J는 리프 노드이다.
>그리고 A, B, C, D는 내부 노드이다.

**깊이** : 루트에서 해당 노드까지의 간선의 수

**높이** : 어떤 노드에서 리프노드까지 가장 긴 간선의 수

> 그림에서 A는 깊이 0, 높이 2이다.
> 그리고 D는 깊이 1, 높이 1이다.

### 트리의 특징

- **하나의 루트노드**와 **0개 이상의 하위 트리**로 구성되어 있다.
- 데이터를 순차적으로 저장하지 않기 때문에 **비선형 자료구조**이다.
- 트리 안에 또 다른 트리가 있는 **재귀적 자료구조**이다.
- **모든 노드가 연결**되고 **순환을 가지지 않는 그래프**이다.
- 노드들이 **부모 자식 관계**를 갖는 계층적 자료구조이며 모든 자식 노드는 **하나의 부모 노드**을 갖는다.
- 노드가 n개인 트리는 항상 **n-1개의 간선**을 가진다.

### 트리의 활용

| <img width="319" alt="Screen Shot 2022-10-18 at 12 51 56 AM" src="https://user-images.githubusercontent.com/59877415/196224815-a6227327-77ba-4a69-baa7-cf6c43560131.png"> | <img width="780" alt="Screen Shot 2022-10-18 at 12 52 39 AM" src="https://user-images.githubusercontent.com/59877415/196224850-0816a8fe-d903-430e-a249-191791ec4597.png"> | <img width="682" alt="Screen Shot 2022-10-18 at 12 53 36 AM" src="https://user-images.githubusercontent.com/59877415/196224864-cb518452-e6f3-4d53-afbc-aa3fc46c6501.png"> |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 컴퓨터의 폴더구조                                         | 2. DOM 트리                                                  | 3. 인덱스 (B+트리)                                           |

> DOM 트리란?
> HTML 문서를 트리구조로 표현해놓은 것이다.
>
> Index란?
> 데이터 베이스 테이블의 검색 속도를 향상시켜주는 자료구조이다.



## 트리의 종류

### 이진 탐색 트리

이진 탐색 트리란 특정한 조건을 만족하는 이진트리이다.

> 이진트리란?
> 각 노드의 자식 노드의 수가 최대 2개인 트리를 뜻한다.

> 특정한 조건이란?
>
> 1. 각 노드들의 키는 중복되지 않아야 한다.
> 2. 루트 노드의 왼쪽 서브트리는 루트 노드의 키보다 작은 키값를 갖는 노드들로 구성되어 있다.
> 3. 루트 노드의 오른쪽 서브트리는 루트 노드의 키보다 큰 키값를 갖는 노드들로 구성되어 있다.
> 4. 루트 노드의 서브 트리도 이진 탐색 트리여야 한다.

<img width="741" alt="Screen Shot 2022-10-18 at 1 34 01 AM" src="https://user-images.githubusercontent.com/59877415/196233098-71a7e255-0d78-4a79-8a46-a391bdda14fe.png">

- 이진 탐색 트리의 특징 때문에 효율적인 탐색 및 삽입, 삭제가 가능하다. (균형이 잡혀있을 경우 O(logn))

> 그림의 이진 탐색트리에서 35를 찾는다면?
>
> 1. 루트노드인 50과 값을 비교하고 찾는 값이 작으므로 left subtree로 내려간다.
> 2. 30과 값을 비교하고 찾는 값이 크므로 right subtree로 내려간다.
> 3. 35를 찾았다.

> 그린의 이진 탐색트리에 65를 삽입한다면?
>
> 1. 루트노드인 50과 값을 비교하고 삽입할 값이 크므로 right subtree로 내려간다.
> 2. 70과 값을 비교하고 삽입할 값이 작으므로 left subtree로 내려간다.
> 3. 60과 값을 비교하고 삽입할 값이 크므로 right subtree로 내려간다.
> 4. 해당 위치에 노드가 없으므로 만들어주고 값에 65를 넣어준다.

- 이진 트리를 순회하는 세가지 방법

  - **중위 순회** : 왼쪽 서브트리 → 루트 → 오른쪽 서브트리의 순으로 트리를 순회하는 방법이다.

    > 위의 그림의 예시에서는 1 30 35 50 60 70 80 순으로 순회하게 된다.

  - **전위 순회** : 루트 → 왼쪽 서브트리 → 오른쪽 서브트리의 순으로 트리를 순회하는 방법이다.

    > 위의 그림의 예시에서는 50 30 1 35 70 60 70 순으로 순회하게 된다.

  - **후위 순회** : 왼쪽 서브트리 → 오른쪽 서브트리 → 루트의 순으로 트리를 순회하는 방법이다.

    > 위의 그림의 예시에서는 1 30 35 50 60 70 80 순으로 순회하게 된다.

### 자가 균형 이진 탐색 트리

> 이진 탐색 트리의 노드들이 한쪽으로 치우칠수록 탐색 및 삽입, 삭제에 걸리는 시간이 늘어나게 된다.
>
> (최악의 경우 링크드리스트와 다를바가 없어져 탐색, 삽입, 삭제에 O(N)의 시간이 걸리게 된다.)
>
> 이러한 경우를 방지하기 위해 트리의 균형이 유지되도록 돕는 트리 자료구조가 바로 자가 균형 이진트리이다.

**자가 균형 이진트리** : 트리에서 노드의 삽입 혹은 삭제가 일어날 때 `균형이 맞도록 조정`이 일어나는 이진트리이다.

> 트리의 균형이 맞다 : 트리의 모든 하위 트리의 높이 차이가 1이하인 상황이다.
>
> 균형 트리 : 균형이 맞는 트리이다.
>
> 편향 트리 : 균형이 맞지 않는 트리이다.

<img width="828" alt="Screen Shot 2022-10-18 at 2 20 17 AM" src="https://user-images.githubusercontent.com/59877415/196242187-7caa59b2-cbb9-4c7e-a29a-d2a403239456.png">

**AVL 트리** : 자가 균형 이진트리의 일종으로 트리에 노드를 삽입 혹은 삭제할 때마다 `자가 균형 조정 메서드`를 호출하여 트리의 균형을 유지한다.

> AVL 트리의 자가 균형 메서드는 회전을 통해 트리의 균형을 유지한다.

<img width="540" alt="Screen Shot 2022-10-18 at 2 20 27 AM" src="https://user-images.githubusercontent.com/59877415/196242226-28cd7440-a29d-448e-84ef-4aa72ef8e717.png">

**Red-Black 트리** : 자가 균형 이진트리의 일종으로 트리에 노드를 삽입 혹은 삭제할 때 `특정한 규칙`을 지키도록 조정이 이루어져 트리의 균형을 유지한다. (특정한 규칙을 준수한다면 트리의 균형이 유지되는 것이 보장된다.)

> Red-Black 트리의 규칙
>
> 1) 각 노드의 색은 red 또는 black이다.
>
> 2) root 노드는 black이다.
>
> 3) 모든 말단노드(leaf node)는 black이다. (NIL이 black이 된다)
>
> 4) red 노드의 자식노드들은 전부 black이다. (즉, red 노드는 연속되어 등장할 수 없다.)
>
> 5) Root 노드에서 시작해서 자손인 leaf노드에 이르는 모든 경로에는 동일한 개수의 black노드가 존재한다.

### 힙

<img width="708" alt="Screen Shot 2022-10-18 at 1 18 40 AM" src="https://user-images.githubusercontent.com/59877415/196229966-c9fc3409-b8bf-46b2-9ee9-f5a8ff8f9dd7.png">

**우선순위 큐**의 구현을 위해 **완전 이진트리**를 이용한 자료구조이다.

- 여러개의 값들 중에서 최댓값(최대 힙) 혹은 최솟값(최소 힙)을 빠르게 찾아내는데 사용한다.

  → 빠르게 최댓값 혹은 최솟값을 찾아내기 위해 힙은 **반정렬 상태** (느슨한 정렬 상태)를 유지한다.

- 삽입 및 삭제 시의 시간 복잡도가 O(n)이다.

- **배열**을 사용해서 구현한다.

  → 삽입 및 삭제시에 **마지막 인덱스에 접근하는 것이 용이**하다.

  <img width="659" alt="Screen Shot 2022-10-18 at 1 27 06 AM" src="https://user-images.githubusercontent.com/59877415/196231715-2db7cfc6-55fe-447a-9d07-1767cbbc1595.png">

  - 0번째 노드는 비워둔다.
  - N번째 노드의 왼쪽 자식의 인덱스 : 2*N
  - N번째 노드의 오른쪽 자식의 인덱스 : 2*N + 1
  - N번째 노드의 부모의 인덱스 : N/2

> 최대 힙 그림에서 7을 삭제한다면?
> 7을 삭제하고 마지막 노드인 3를 그 자리에 놓는다. 이후 자식 노드와의 재귀적 비교를 통해 자신의 자리를 찾아준다.

> 최소 힙 그림에서 3을 삽입한다면?
> 완전 이진트리가 유지되도록 5의 오른쪽 자식 노드를 생성하고 값으로 3을 넣는다. 이후 부모 노드와의 재귀적 비교를 통해 자신의 자리를 찾아준다.

### 트라이 자료구조

<img width="768" alt="Screen Shot 2022-10-18 at 12 58 38 AM" src="https://user-images.githubusercontent.com/59877415/196225917-241514d6-5163-4c74-9003-468457c10119.png">

**문자열을 저장하고 효율적으로 탐색**하기 위한 **트리 형태의 자료구조**이다.

- 문자열을 탐색할 때 속도가 무척 빠르다.

  > 길이가 M인 문자열을 탐색할 때의 시간 복잡도는 O(M)이 된다.
  > (문자열 탐색시 저장된 문자열의 개수에 영향을 받지 않는다.)

- 각 노드들이 자식 노드에 대한 포인터를 저장해야하므로 공간 복잡도가 높을 수 있다. (메모리 측면에서 비효율적일 수 있다.)

## References

[[자료구조] 트리(Tree)의 개념과 정리](https://go-coding.tistory.com/m/7)

[[자료구조] 트리 (Tree)](https://yoongrammer.tistory.com/m/68)

[선형(Linear) / 비선형(NonLinear) 자료구조](https://goodgid.github.io/DS-Linear-and-NonLinear/)

[[자료구조] 이진 탐색 트리 (BST, Binary Search Tree)](https://yoongrammer.tistory.com/m/71)

[이진 탐색 트리와 자가 균형 이진 탐색 트리](https://lgphone.tistory.com/m/90)

[[알고리즘] Red-Black Tree : 레드 블랙 트리](https://blogshine.tistory.com/m/102)

[[자료구조] 트라이 (Trie)](https://velog.io/@kimdukbae/자료구조-트라이-Trie)

[[자료구조] 힙(heap)이란](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)

[사진 출처](https://rebro.kr/m/167)

